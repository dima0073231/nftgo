require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
const http = require('http');
const WebSocket = require('ws');
const CryptoBotAPI = require('crypto-bot-api');
const axios = require('axios');
const cron = require('node-cron');
const frogs = new Map(); // Ð¥Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð¶Ð°Ð±: { id, x, y, playerId }
const User = require('./api/users'); // ÐœÐ¾Ð´ÐµÐ»ÑŒ
const connectDB = require('./db/db'); // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº MongoDB
const Invoice = require('./api/invoice'); // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÐµÐ»Ð¸ Invoice
const TonTransaction = require('./api/tonTransaction'); // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÐµÐ»Ð¸ TonTransaction

const app = express();

// Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° CryptoBotAPI
const cryptoBotClient = new CryptoBotAPI(process.env.CRYPTOBOT_TOKEN);

// âœ… CORS
app.use(cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.options('*', cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.use(express.json());

// ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº Ð‘Ð”
connectDB();

// ðŸ“¦ Ð Ð¾ÑƒÑ‚Ñ‹
app.get('/api/users', async (req, res) => {
  try {
    const users = await User.find().sort({ createdAt: -1 });
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    res.status(201).json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/users/:telegramId/history', async (req, res) => {
  let telegramId = Number(req.params.telegramId);
  if (!telegramId || isNaN(telegramId)) {
    return res.status(400).json({ error: 'ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ telegramId' });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });
    }
    res.status(200).json({ history: user.gameHistory || [] });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÑ‚Ð°Ñ‚ÑƒÑ TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸ Ð¿Ð¾ Ñ…ÐµÑˆÑƒ
app.get('/api/ton/transaction/:txHash', async (req, res) => {
  try {
    const txHash = req.params.txHash;
    if (!txHash) return res.status(400).json({ ok: false, error: "txHash required" });

    // Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ñ ÑÐµÑ€Ð²ÐµÑ€Ð°
    const response = await axios.get(
      `https://toncenter.com/api/v2/getTransaction?hash=${txHash}&api_key=${process.env.TONCENTER_API_TOKEN}`
    );
    if (response.data.ok && response.data.result) {
      return res.json({ ok: true, result: response.data.result });
    }
    return res.status(404).json({ ok: false, error: "Transaction not found" });
  } catch (error) {
    console.error("Error verifying TON transaction:", error);
    res.status(500).json({ ok: false, error: "Server error" });
  }
});



// === Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° ===
app.post('/api/cryptobot/create-invoice', async (req, res) => {
  let { amount } = req.body;
  amount = Number(amount);
  if (!amount || isNaN(amount) || amount < 1) {
    return res.status(400).json({ ok: false, error: 'ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð°Ñ ÑÑƒÐ¼Ð¼Ð° â€” 1 TON' });
  }

  try {
    console.log('Ð—Ð°Ð¿Ñ€Ð¾Ñ Ðº CryptoBot API:', {
      asset: 'TON',
      amount: amount.toString(),
      description: 'ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ñ‡ÐµÑ€ÐµÐ· NFTGo',
      hidden_message: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ!',
      paid_btn_name: 'openBot',
      paid_btn_url: 'https://t.me/nftgo_bot'
    });

    const response = await axios.post(
      'https://pay.crypt.bot/api/createInvoice',
      {
        asset: 'TON',
        amount: amount.toString(), // CryptoBot API Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ ÑÑ‚Ñ€Ð¾ÐºÑƒ
        description: 'ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ñ‡ÐµÑ€ÐµÐ· NFTGo',
        hidden_message: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ!',
        paid_btn_name: 'openBot', // Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾ Ð½Ð° Ð²Ð°Ð»Ð¸Ð´Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
        paid_btn_url: 'https://t.me/nftgo_bot'
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Crypto-Pay-API-Token': process.env.CRYPTOBOT_TOKEN
        }
      }
    );

    console.log('ÐžÑ‚Ð²ÐµÑ‚ Ð¾Ñ‚ CryptoBot API:', response.data);

    if (!response.data.ok || !response.data.result?.invoice_id) {
      return res.status(400).json({ ok: false, error: response.data.description || 'ÐžÑˆÐ¸Ð±ÐºÐ° CryptoBot' });
    }

    // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    const newInvoice = new Invoice({
      invoiceId: response.data.result.invoice_id, // Ð£Ð±ÐµÐ´Ð¸Ð¼ÑÑ, Ñ‡Ñ‚Ð¾ invoice_id Ð¿ÐµÑ€ÐµÐ´Ð°ÐµÑ‚ÑÑ
      telegramId: req.body.telegramId, // Telegram ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      amount, // Ð¡ÑƒÐ¼Ð¼Ð° Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°
      status: 'pending' // Ð¡Ñ‚Ð°Ñ‚ÑƒÑ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°
    });
    await newInvoice.save();

    res.json({ ok: true, result: response.data.result });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° CryptoBot:', err?.response?.data || err);
    res.status(500).json({ ok: false, error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°' });
  }
});

// ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¼Ð°Ñ€ÑˆÑ€ÑƒÑ‚Ð° Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸ crypto-bot-api
app.get('/api/cryptobot/invoice/:invoiceId', async (req, res) => {
  try {
    const { invoiceId } = req.params;
    if (!invoiceId) return res.status(400).json({ ok: false, error: 'invoiceId required' });

    // ÐÐ¾Ð²Ñ‹Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ñ‡ÐµÑ€ÐµÐ· getInvoices
    const invoicesData = await cryptoBotClient.getInvoices({ invoice_ids: [invoiceId] });
    const invoice = invoicesData.items?.[0];
    if (!invoice) {
      return res.status(404).json({ ok: false, error: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });
    }
    res.json({ ok: true, result: invoice });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°:', err);
    res.status(500).json({ ok: false, error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¿Ñ€Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°' });
  }
});


app.get('/api/cryptobot/invoice', async (req, res) => {
  try {
    const invoices = await Invoice.find(); // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÑÐµ Ð¸Ð½Ð²Ð¾Ð¹ÑÑ‹ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    res.json({ ok: true, result: invoices });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ð¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ¾Ð²:', err);
    res.status(500).json({ ok: false, error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ð¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ¾Ð²' });
  }
});



// Ð¦ÐµÐ½Ñ‚Ñ€Ð°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°
async function updateInvoice(invoiceId) {
  try {
    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    const invoice = await Invoice.findOne({ invoiceId });
    if (!invoice) {
      return { ok: false, error: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' };
    }

    // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¸Ð½Ð²Ð¾Ð¹Ñ Ñ‡ÐµÑ€ÐµÐ· getInvoices (crypto-bot-api)
    const invoicesData = await cryptoBotClient.getInvoices({ invoice_ids: [invoiceId] });
    const invoiceData = invoicesData.items?.[0];
    if (!invoiceData) {
      return { ok: false, error: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² CryptoBot' };
    }

    if (invoiceData.status === 'paid') {
      // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
      invoice.status = 'paid';
      await invoice.save();

      // ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      const user = await User.findOne({ telegramId: invoice.telegramId });
      if (user) {
        user.balance += invoice.amount;
        await user.save();
      }

      return { ok: true, message: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð¾Ð¿Ð»Ð°Ñ‡ÐµÐ½, Ð±Ð°Ð»Ð°Ð½Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»Ñ‘Ð½' };
    } else {
      return { ok: true, message: `Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð¸Ð¼ÐµÐµÑ‚ ÑÑ‚Ð°Ñ‚ÑƒÑ: ${invoiceData.status}` };
    }
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°:', err);
    return { ok: false, error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' };
  }
}

// === ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ð¸ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð±Ð°Ð»Ð°Ð½ÑÐ° ===
app.post('/api/cryptobot/update-invoice', async (req, res) => {
  const { invoiceId } = req.body;

  if (!invoiceId) {
    return res.status(400).json({ ok: false, error: 'ÐÐµ ÑƒÐºÐ°Ð·Ð°Ð½ invoiceId' });
  }

  const result = await updateInvoice(invoiceId);
  if (!result.ok) {
    return res.status(400).json(result);
  }

  res.json(result);
});


app.post('/api/users/:telegramId/history', async (req, res) => {
  let telegramId = Number(req.params.telegramId);
  if (!telegramId || isNaN(telegramId)) {
    return res.status(400).json({ error: 'ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ telegramId' });
  }
  const { date, betAmount, coefficient, result } = req.body;
  if (!date || !betAmount || !coefficient || !result) {
    return res.status(400).json({ error: 'ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð´Ð°Ð½Ð½Ñ‹Ñ…' });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });
    }
    user.gameHistory.push({ date, betAmount, coefficient, result });
    await user.save();
    res.status(200).json({ message: 'Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð°' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/addbalance/ton', async (req, res) => {
  let telegramId = Number(req.body.telegramId);
  const amount = req.body.amount;
  if (!telegramId || isNaN(telegramId) || typeof amount !== "number" || !isFinite(amount)) {
    return res.status(400).json({ error: "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ" });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½" });
    }
    user.balance += amount;
    await user.save();
    res.json({ message: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½", balance: user.balance });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// === ÐÐ¾Ð²Ñ‹Ð¹ Ñ€Ð¾ÑƒÑ‚: Ð½Ð°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ð¿Ð¾ÑÐ»Ðµ Ð¾Ð¿Ð»Ð°Ñ‚Ñ‹ CryptoBot ===

app.post('/api/addbalance/cryptobot', async (req, res) => {
  try {
    let { telegramId, invoiceId } = req.body;
    telegramId = Number(telegramId);
    if (!telegramId || isNaN(telegramId) || !invoiceId) {
      return res.status(400).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ (telegramId Ð¸Ð»Ð¸ invoiceId)' });
    }

    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ°: Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð»ÑÑ Ð»Ð¸ ÑƒÐ¶Ðµ ÑÑ‚Ð¾Ñ‚ invoiceId
    const existingInvoice = await Invoice.findOne({ invoiceId });
    if (existingInvoice) {
      return res.status(400).json({ error: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ ÑƒÐ¶Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½' });
    }

    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ñ‡ÐµÑ€ÐµÐ· Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÑƒ crypto-bot-api
    const invoice = await cryptoBotClient.getInvoice(invoiceId);

    if (invoice.status !== 'paid') {
      return res.status(400).json({ error: 'Ð˜Ð½Ð²Ð¾Ð¹Ñ Ð½Ðµ Ð¾Ð¿Ð»Ð°Ñ‡ÐµÐ½' });
    }

    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });
    }

    const amount = Number(invoice.amount);
    user.balance += amount;
    await user.save();

    // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¸Ð½Ð²Ð¾Ð¹Ñ Ð² Ð‘Ð”
    await Invoice.create({
      invoiceId,
      telegramId,
      amount,
      status: invoice.status
    });

    res.json({ message: 'Ð‘Ð°Ð»Ð°Ð½Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½', balance: user.balance });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð½Ð°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ñ‡ÐµÑ€ÐµÐ· CryptoBot:', err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¿Ñ€Ð¸ Ð½Ð°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÐ°' });
  }
});



const { ethers } = require('ethers');


// ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð»Ð¾ÐºÑ‡ÐµÐ¹Ð½Ð°
const provider = new ethers.providers.JsonRpcProvider(process.env.BLOCKCHAIN_PROVIDER_URL);
const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

// Ð Ð¾ÑƒÑ‚ Ð´Ð»Ñ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð±Ð°Ð»Ð°Ð½ÑÐ°
app.post('/addbalance', async (req, res) => {
    try {
        const { address, transactionHash } = req.body;
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸ÑŽ
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            return res.status(400).send('Transaction not found');
        }
        
        // Ð–Ð´ÐµÐ¼ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸
        const receipt = await tx.wait();
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‡Ñ‚Ð¾ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð° Ð¸ Ð°Ð´Ñ€ÐµÑ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»Ñ - Ð½Ð°Ñˆ
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            return res.status(400).send('Invalid transaction');
        }
        
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑƒÐ¼Ð¼Ñƒ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð° (Ð² wei)
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
        await User.updateOne(
            { address: address.toLowerCase() },
            { $inc: { balance: parseFloat(amountInEth) } }
        );
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        res.status(500).send('Server error');
    }
});
const Transaction = require('./models/Transaction');

// ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ñ€Ð¾ÑƒÑ‚ /addbalance
app.post('/addbalance', async (req, res) => {
    let txRecord;
    try {
        const { address, transactionHash } = req.body;
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÐµÑÑ‚ÑŒ Ð»Ð¸ ÑƒÐ¶Ðµ Ñ‚Ð°ÐºÐ°Ñ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ
        const existingTx = await Transaction.findOne({ txHash: transactionHash });
        if (existingTx) {
            return res.status(400).send('Transaction already processed');
        }
        
        // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð¾ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸
        txRecord = new Transaction({
            userAddress: address.toLowerCase(),
            txHash: transactionHash,
            status: 'pending'
        });
        await txRecord.save();
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸ÑŽ Ð² Ð±Ð»Ð¾ÐºÑ‡ÐµÐ¹Ð½Ðµ
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Transaction not found');
        }
        
        // Ð–Ð´ÐµÐ¼ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ
        const receipt = await tx.wait();
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð²Ð°Ð»Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Invalid transaction');
        }
        
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑƒÐ¼Ð¼Ñƒ
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð±Ð°Ð»Ð°Ð½Ñ Ð¸ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð¾ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸
        await Promise.all([
            User.updateOne(
                { address: address.toLowerCase() },
                { $inc: { balance: parseFloat(amountInEth) } }
            ),
            txRecord.updateOne({
                status: 'completed',
                amount: parseFloat(amountInEth),
                blockNumber: receipt.blockNumber
            })
        ]);
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        if (txRecord) {
            await txRecord.updateOne({ status: 'failed' });
        }
        res.status(500).send('Server error');
    }
});
app.get('/testdb', async (req, res) => {
    try {
        const users = await User.find();
        const txs = await Transaction.find();
        res.send({ users, txs });
    } catch (error) {
        res.status(500).send(error.message);
    }
});

// ÐÐ¾Ð²Ñ‹Ð¹ Ñ€Ð¾ÑƒÑ‚ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹
app.get('/transactions/:address', async (req, res) => {
    try {
        const transactions = await Transaction.find({ 
            userAddress: req.params.address.toLowerCase() 
        }).sort({ timestamp: -1 });
        
        res.send(transactions);
    } catch (error) {
        res.status(500).send('Server error');
    }
});

// === Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹ Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ ===
app.post('/api/ton/add-transaction', async (req, res) => {
  try {
    const { txHash, telegramId, amount } = req.body;
    if (!txHash || !telegramId || !amount) {
      return res.status(400).json({ error: 'ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹ txHash, telegramId Ð¸ amount' });
    }
    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð° Ð´ÑƒÐ±Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ
    const exists = await TonTransaction.findOne({ txHash });
    if (exists) {
      return res.status(400).json({ error: 'Ð¢Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ ÑƒÐ¶Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð°' });
    }
    const tx = new TonTransaction({ txHash, telegramId, amount, status: 'pending' });
    await tx.save();
    res.json({ ok: true, message: 'TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð°', tx });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ð¸ TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸:', err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¿Ñ€Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ð¸ TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸' });
  }
});

// === ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÑ‚Ð°Ñ‚ÑƒÑÐ° TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸ (Ð´Ð»Ñ ton.js) ===
app.get('/api/ton/check-status/:txHash', async (req, res) => {
  try {
    const { txHash } = req.params;
    if (!txHash) return res.status(400).json({ status: 'error', error: 'txHash required' });
    const tx = await TonTransaction.findOne({ txHash });
    if (!tx) return res.status(404).json({ status: 'not_found' });
    if (tx.status === 'confirmed') {
      return res.json({ status: 'confirmed' });
    } else {
      return res.json({ status: 'pending' });
    }
  } catch (err) {
    res.status(500).json({ status: 'error', error: err.message });
  }
});



// === CRON: ÐŸÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ¾Ð² Ð¸Ð½Ð²Ð¾Ð¹ÑÐ¾Ð² CryptoBot ===
cron.schedule('*/2 * * * *', async () => {
  try {
    const invoices = await Invoice.find({ status: 'pending' });
    for (const invoice of invoices) {
      try {
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð°ÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° Ñ‡ÐµÑ€ÐµÐ· CryptoBot API
        const invoicesData = await cryptoBotClient.getInvoices({ invoice_ids: [invoice.invoiceId] });
        const invoiceData = invoicesData.items?.[0];
        if (invoiceData && invoiceData.status === 'paid') {
          invoice.status = 'paid';
          await invoice.save();
          // ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
          const user = await User.findOne({ telegramId: invoice.telegramId });
          if (user) {
            user.balance += invoice.amount;
            await user.save();
            console.log(`Ð‘Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ${invoice.telegramId} Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½ Ð½Ð° ${invoice.amount} TON`);
          }
        }
      } catch (err) {
        console.error(`ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ° ${invoice.invoiceId}:`, err?.response?.data || err);
      }
    }
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ¾Ð² CryptoBot:', err);
  }
});

// === CRON: ÐŸÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ¾Ð² TON-Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹ ===
cron.schedule('*/2 * * * *', async () => {
  try {
    const pendingTxs = await TonTransaction.find({ status: 'pending' });
    for (const tx of pendingTxs) {
      try {
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸ Ñ‡ÐµÑ€ÐµÐ· toncenter (Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ BOC ÐºÐ°Ðº hash, ÐµÑÐ»Ð¸ ÑÑ‚Ð¾ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ hash)
        const response = await axios.get(
          `https://tonapi.io/v2/blockchain/transactions/${tx.txHash}`
        );
        // Ð•ÑÐ»Ð¸ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð°
        if (response.data && response.data.transaction && response.data.transaction.status === 'finalized') {
          tx.status = 'confirmed';
          await tx.save();
          // ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
          const user = await User.findOne({ telegramId: tx.telegramId });
          if (user) {
            user.balance += tx.amount;
            await user.save();
            console.log(`TON: Ð‘Ð°Ð»Ð°Ð½Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ${tx.telegramId} Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½ Ð½Ð° ${tx.amount} TON`);
          }
        }
      } catch (err) {
        // ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¸Ð»Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐ° â€” Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼
        // ÐœÐ¾Ð¶Ð½Ð¾ Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð´Ð»Ñ Ð¾Ñ‚Ð»Ð°Ð´ÐºÐ¸: console.error(`TON: ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸ ${tx.txHash}:`, err?.response?.data || err);
      }
    }
  } catch (err) {
    console.error('TON: ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹:', err);
  }
});



// âœ… Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ HTTP-ÑÐµÑ€Ð²ÐµÑ€ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ (Ð´Ð»Ñ WebSocket)
const server = http.createServer(app); // âœ… Ð¾Ð±Ð¾Ñ€Ð°Ñ‡Ð¸Ð²Ð°ÐµÐ¼ express Ð² http-ÑÐµÑ€Ð²ÐµÑ€
const wss = new WebSocket.Server({ server });

let clients = new Set();

wss.on('connection', (ws) => {
  clients.add(ws);
  console.log('ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ ÐºÐ»Ð¸ÐµÐ½Ñ‚. Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ð¾Ð½Ð»Ð°Ð¹Ð½:', clients.size);
  broadcastOnline();

  ws.on('close', () => {
    clients.delete(ws);
    console.log('ÐšÐ»Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ. Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ð¾Ð½Ð»Ð°Ð¹Ð½:', clients.size);
    broadcastOnline();
  });
});
socket.on('message', (data) => {
  const msg = JSON.parse(data);
  
  // Ð˜Ð³Ñ€Ð¾Ðº ÐºÐ»Ð¸ÐºÐ½ÑƒÐ» Ð¿Ð¾ Ð¶Ð°Ð±Ðµ
  if (msg.type === 'frogClick') {
    const frog = gameState.frogs.find(f => f.id === msg.frogId);
    if (frog && !frog.clickedBy) {
      frog.clickedBy = msg.playerId;
      gameState.scores[msg.playerId] = (gameState.scores[msg.playerId] || 0) + 1;
      
      // Ð Ð°ÑÑÑ‹Ð»Ð°ÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²ÑÐµÐ¼
      broadcastGameState();
    }
  }
  
  // Ð˜Ð³Ñ€Ð¾Ðº Ð´Ð¾Ð±Ð°Ð²Ð¸Ð» Ð½Ð¾Ð²ÑƒÑŽ Ð¶Ð°Ð±Ñƒ
  else if (msg.type === 'addFrog') {
    gameState.frogs.push({
      id: Date.now().toString(),
      x: msg.x,
      y: msg.y,
      clickedBy: null
    });
    broadcastGameState();
  }
});

// ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ñ‚ÐµÐºÑƒÑ‰ÐµÐµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð¸Ð³Ñ€Ñ‹ Ð²ÑÐµÐ¼ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°Ð¼
function broadcastGameState() {
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({
        type: 'gameStateUpdate',
        gameState
      }));
    }
  });
}


function broadcastOnline() {
  const count = clients.size;
  const message = JSON.stringify({ online: count });

  clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}
app.get('/users/:param')  // ÐžÑˆÐ¸Ð±ÐºÐ°: Ð¿Ð¾ÑÐ»Ðµ `:` Ð½ÐµÑ‚ Ð¸Ð¼ÐµÐ½Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°

// ðŸš€ Ð·Ð°Ð¿ÑƒÑÐº
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`âœ… Ð¡ÐµÑ€Ð²ÐµÑ€ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Ð½Ð° Ð¿Ð¾Ñ€Ñ‚Ñƒ ${PORT}`);
});

