require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
const http = require('http');
const WebSocket = require('ws');

const User = require('./api/users'); // –ú–æ–¥–µ–ª—å
const connectDB = require('./db/db'); // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB

const app = express();

// ‚úÖ CORS
app.use(cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.options('*', cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.use(express.json());

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
connectDB();

// üì¶ –†–æ—É—Ç—ã
app.get('/api/users', async (req, res) => {
  try {
    const users = await User.find().sort({ createdAt: -1 });
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    res.status(201).json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/users/:telegramId/history', async (req, res) => {
  const { telegramId } = req.params;

  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    res.status(200).json({ history: user.gameHistory || [] });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å TON-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ —Ö–µ—à—É
app.get('/api/ton/transaction/:txHash', async (req, res) => {
  try {
    const txHash = req.params.txHash;
    if (!txHash) return res.status(400).json({ ok: false, error: "txHash required" });

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å —Å–µ—Ä–≤–µ—Ä–∞
    const response = await axios.get(
      `https://toncenter.com/api/v2/getTransaction?hash=${txHash}&api_key=${process.env.TONCENTER_API_TOKEN}`
    );
    if (response.data.ok && response.data.result) {
      return res.json({ ok: true, result: response.data.result });
    }
    return res.status(404).json({ ok: false, error: "Transaction not found" });
  } catch (error) {
    console.error("Error verifying TON transaction:", error);
    res.status(500).json({ ok: false, error: "Server error" });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å CryptoBot invoice –ø–æ invoiceId
app.get('/api/cryptobot/invoice/:invoiceId', async (req, res) => {
  try {
    const invoiceId = req.params.invoiceId;
    if (!invoiceId) return res.status(400).json({ ok: false, error: "invoiceId required" });

    const response = await axios.get(
      `https://pay.crypt.bot/api/getInvoice?invoice_id=${invoiceId}`,
      {
        headers: {
          "Crypto-Pay-API-Token": process.env.CRYPTOBOT_TOKEN
        }
      }
    );
    if (response.data.ok && response.data.result) {
      return res.json({ ok: true, result: response.data.result });
    }
    return res.status(404).json({ ok: false, error: "Invoice not found" });
  } catch (error) {
    console.error("Error verifying CryptoBot invoice:", error);
    res.status(500).json({ ok: false, error: "Server error" });
  }
});

app.post("/api/cryptobot/create-invoice", async (req, res) => {
  try {
    const { amount } = req.body;
    if (!amount || typeof amount !== "number" || amount <= 0) {
      return res.status(400).json({ ok: false, error: "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞" });
    }

    const response = await axios.post(
      "https://pay.crypt.bot/api/createInvoice",
      {
        asset: "TON",
        amount,
        description: "–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ NFTGo",
        hidden_message: "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ!",
        paid_btn_name: "open_bot",
        paid_btn_url: "https://t.me/nftgo_bot"
      },
      {
        headers: {
          "Content-Type": "application/json",
          "Crypto-Pay-API-Token": process.env.CRYPTOBOT_TOKEN
        }
      }
    );

    if (!response.data.ok) {
      return res.status(400).json({ ok: false, error: response.data.description || "–û—à–∏–±–∫–∞ CryptoBot" });
    }

    res.json({ ok: true, result: response.data.result });
  } catch (err) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–Ω–≤–æ–π—Å–∞ CryptoBot:", err);
    res.status(500).json({ ok: false, error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–Ω–≤–æ–π—Å–∞" });
  }
});

app.post('/api/users/:telegramId/history', async (req, res) => {
  const { telegramId } = req.params;
  const { date, betAmount, coefficient, result } = req.body;

  if (!date || !betAmount || !coefficient || !result) {
    return res.status(400).json({ error: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö' });
  }

  try {
    const user = await User.findOne({ telegramId });

    if (!user) {
      return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    user.gameHistory.push({ date, betAmount, coefficient, result });
    await user.save();

    res.status(200).json({ message: '–ò—Å—Ç–æ—Ä–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/addbalance/ton', async (req, res) => {
  try {
    const { telegramId, amount } = req.body; // amount ‚Äî —Å–∫–æ–ª—å–∫–æ –¥–æ–±–∞–≤–∏—Ç—å

    if (!telegramId || typeof amount !== "number" || !isFinite(amount)) {
      return res.status(400).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ" });
    }

    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    user.balance += amount;
    await user.save();

    res.json({ message: "–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω", balance: user.balance });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/addbalance/cryptobot', async (req, res) => {
  try {
    const { telegramId, amount } = req.body; // amount ‚Äî —Å–∫–æ–ª—å–∫–æ –¥–æ–±–∞–≤–∏—Ç—å

    if (!telegramId || typeof amount !== "number" || !isFinite(amount)) {
      return res.status(400).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ" });
    }

    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    user.balance += amount;
    await user.save();

    res.json({ message: "–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω", balance: user.balance });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});



const { ethers } = require('ethers');


// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–ª–æ–∫—á–µ–π–Ω–∞
const provider = new ethers.providers.JsonRpcProvider(process.env.BLOCKCHAIN_PROVIDER_URL);
const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

// –†–æ—É—Ç –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞
app.post('/addbalance', async (req, res) => {
    try {
        const { address, transactionHash } = req.body;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            return res.status(400).send('Transaction not found');
        }
        
        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const receipt = await tx.wait();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ –∏ –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è - –Ω–∞—à
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            return res.status(400).send('Invalid transaction');
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º—É –ø–µ—Ä–µ–≤–æ–¥–∞ (–≤ wei)
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await User.updateOne(
            { address: address.toLowerCase() },
            { $inc: { balance: parseFloat(amountInEth) } }
        );
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        res.status(500).send('Server error');
    }
});
const Transaction = require('./models/Transaction');

// –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ä–æ—É—Ç /addbalance
app.post('/addbalance', async (req, res) => {
    try {
        const { address, transactionHash } = req.body;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
        const existingTx = await Transaction.findOne({ txHash: transactionHash });
        if (existingTx) {
            return res.status(400).send('Transaction already processed');
        }
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const txRecord = new Transaction({
            userAddress: address.toLowerCase(),
            txHash: transactionHash,
            status: 'pending'
        });
        await txRecord.save();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –±–ª–æ–∫—á–µ–π–Ω–µ
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Transaction not found');
        }
        
        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        const receipt = await tx.wait();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Invalid transaction');
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º—É
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏ –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        await Promise.all([
            User.updateOne(
                { address: address.toLowerCase() },
                { $inc: { balance: parseFloat(amountInEth) } }
            ),
            txRecord.updateOne({
                status: 'completed',
                amount: parseFloat(amountInEth),
                blockNumber: receipt.blockNumber
            })
        ]);
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        if (txRecord) {
            await txRecord.updateOne({ status: 'failed' });
        }
        res.status(500).send('Server error');
    }
});
app.get('/testdb', async (req, res) => {
    try {
        const users = await User.find();
        const txs = await Transaction.find();
        res.send({ users, txs });
    } catch (error) {
        res.status(500).send(error.message);
    }
});

// –ù–æ–≤—ã–π —Ä–æ—É—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
app.get('/transactions/:address', async (req, res) => {
    try {
        const transactions = await Transaction.find({ 
            userAddress: req.params.address.toLowerCase() 
        }).sort({ timestamp: -1 });
        
        res.send(transactions);
    } catch (error) {
        res.status(500).send('Server error');
    }
});
// ‚úÖ –°–æ–∑–¥–∞—ë–º HTTP-—Å–µ—Ä–≤–µ—Ä –≤—Ä—É—á–Ω—É—é (–¥–ª—è WebSocket)
const server = http.createServer(app); // ‚úÖ –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º express –≤ http-—Å–µ—Ä–≤–µ—Ä
const wss = new WebSocket.Server({ server });

let clients = new Set();

wss.on('connection', (ws) => {
  clients.add(ws);
  console.log('–ü–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫–ª–∏–µ–Ω—Ç. –°–µ–π—á–∞—Å –æ–Ω–ª–∞–π–Ω:', clients.size);
  broadcastOnline();

  ws.on('close', () => {
    clients.delete(ws);
    console.log('–ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–∏–ª—Å—è. –°–µ–π—á–∞—Å –æ–Ω–ª–∞–π–Ω:', clients.size);
    broadcastOnline();
  });
});

function broadcastOnline() {
  const count = clients.size;
  const message = JSON.stringify({ online: count });

  clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}
app.get('/users/:param')  // –û—à–∏–±–∫–∞: –ø–æ—Å–ª–µ `:` –Ω–µ—Ç –∏–º–µ–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞

// üöÄ –∑–∞–ø—É—Å–∫
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
});