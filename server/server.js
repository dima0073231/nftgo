require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
const http = require('http');
const WebSocket = require('ws');

const User = require('./api/users'); // –ú–æ–¥–µ–ª—å
const connectDB = require('./db/db'); // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB

const app = express();

// ‚úÖ CORS
app.use(cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.options('*', cors({
  origin: 'https://dima0073231.github.io',
  credentials: true
}));


app.use(express.json());

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
connectDB();

// üì¶ –†–æ—É—Ç—ã
app.get('/api/users', async (req, res) => {
  try {
    const users = await User.find().sort({ createdAt: -1 });
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    res.status(201).json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/users/:telegramId/history', async (req, res) => {
  let telegramId = Number(req.params.telegramId);
  if (!telegramId || isNaN(telegramId)) {
    return res.status(400).json({ error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π telegramId' });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    res.status(200).json({ history: user.gameHistory || [] });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å TON-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ —Ö–µ—à—É
app.get('/api/ton/transaction/:txHash', async (req, res) => {
  try {
    const txHash = req.params.txHash;
    if (!txHash) return res.status(400).json({ ok: false, error: "txHash required" });

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å —Å–µ—Ä–≤–µ—Ä–∞
    const response = await axios.get(
      `https://toncenter.com/api/v2/getTransaction?hash=${txHash}&api_key=${process.env.TONCENTER_API_TOKEN}`
    );
    if (response.data.ok && response.data.result) {
      return res.json({ ok: true, result: response.data.result });
    }
    return res.status(404).json({ ok: false, error: "Transaction not found" });
  } catch (error) {
    console.error("Error verifying TON transaction:", error);
    res.status(500).json({ ok: false, error: "Server error" });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å CryptoBot invoice –ø–æ invoiceId
app.get('/api/cryptobot/invoice/:invoiceId', async (req, res) => {
  try {
    const invoiceId = req.params.invoiceId;
    if (!invoiceId) return res.status(400).json({ ok: false, error: "invoiceId required" });

    const response = await axios.get(
      `https://pay.crypt.bot/api/getInvoice?invoice_id=${invoiceId}`,
      {
        headers: {
          "Crypto-Pay-API-Token": process.env.CRYPTOBOT_TOKEN
        }
      }
    );
    if (response.data.ok && response.data.result) {
      return res.json({ ok: true, result: response.data.result });
    }
    return res.status(404).json({ ok: false, error: "Invoice not found" });
  } catch (error) {
    console.error("Error verifying CryptoBot invoice:", error);
    res.status(500).json({ ok: false, error: "Server error" });
  }
});

app.post("/api/cryptobot/create-invoice", async (req, res) => {
  try {
    let { amount, test } = req.body;
    amount = Number(amount);
    if (!amount || isNaN(amount) || amount < 1) {
      return res.status(400).json({ ok: false, error: "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ ‚Äî 1 TON" });
    }

    // –¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º: –Ω–µ —Å–æ–∑–¥–∞—ë–º —Ä–µ–∞–ª—å–Ω—ã–π –∏–Ω–≤–æ–π—Å, –∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–µ–π–∫–æ–≤—ã–π invoice_id –∏ —Å—Å—ã–ª–∫—É
    if (test) {
      const fakeInvoiceId = 'test_invoice_' + Math.floor(Math.random() * 1000000);
      const testBotUrl = `https://t.me/nftgo_bot?start=invoice_${fakeInvoiceId}`;
      return res.json({
        ok: true,
        result: {
          invoice_id: fakeInvoiceId,
          pay_url: 'https://t.me/nftgo_bot',
          status: 'paid',
          paid_btn_url: testBotUrl,
          test_bot_url: testBotUrl
        }
      });
    }

    const response = await axios.post(
      "https://pay.crypt.bot/api/createInvoice",
      {
        asset: "TON",
        amount: amount.toString(), // CryptoBot API —Ç—Ä–µ–±—É–µ—Ç —Å—Ç—Ä–æ–∫—É
        description: "–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ NFTGo",
        hidden_message: "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ!",
        paid_btn_name: "openBot",
        paid_btn_url: "https://t.me/nftgo_bot"
      },
      {
        headers: {
          "Content-Type": "application/json",
          "Crypto-Pay-API-Token": process.env.CRYPTOBOT_TOKEN
        }
      }
    );

    if (!response.data.ok) {
      return res.status(400).json({ ok: false, error: response.data.description || "–û—à–∏–±–∫–∞ CryptoBot" });
    }

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ –±–æ—Ç–∞ —Å invoiceId (–¥–ª—è —Ç–µ—Å—Ç–∞)
    const invoiceId = response.data.result.invoice_id;
    const testBotUrl = `https://t.me/nftgo_bot?start=invoice_${invoiceId}`;
    response.data.result.test_bot_url = testBotUrl;
    console.log('–°—Å—ã–ª–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ –±–æ—Ç–∞:', testBotUrl);

    res.json({ ok: true, result: response.data.result });
  } catch (err) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–Ω–≤–æ–π—Å–∞ CryptoBot:", err?.response?.data || err);
    res.status(500).json({ ok: false, error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–Ω–≤–æ–π—Å–∞" });
  }
});

app.post('/api/users/:telegramId/history', async (req, res) => {
  let telegramId = Number(req.params.telegramId);
  if (!telegramId || isNaN(telegramId)) {
    return res.status(400).json({ error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π telegramId' });
  }
  const { date, betAmount, coefficient, result } = req.body;
  if (!date || !betAmount || !coefficient || !result) {
    return res.status(400).json({ error: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö' });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    user.gameHistory.push({ date, betAmount, coefficient, result });
    await user.save();
    res.status(200).json({ message: '–ò—Å—Ç–æ—Ä–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/addbalance/ton', async (req, res) => {
  let telegramId = Number(req.body.telegramId);
  const amount = req.body.amount;
  if (!telegramId || isNaN(telegramId) || typeof amount !== "number" || !isFinite(amount)) {
    return res.status(400).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ" });
  }
  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }
    user.balance += amount;
    await user.save();
    res.json({ message: "–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω", balance: user.balance });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/addbalance/cryptobot', async (req, res) => {
  try {
    let { telegramId, invoiceId } = req.body;
    telegramId = Number(telegramId);
    if (!telegramId || isNaN(telegramId) || !invoiceId) {
      return res.status(400).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (telegramId –∏–ª–∏ invoiceId)" });
    }

    // –¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º: –µ—Å–ª–∏ invoiceId –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å test_invoice_, —Å—á–∏—Ç–∞–µ–º –æ–ø–ª–∞—á–µ–Ω–Ω—ã–º
    if (invoiceId.startsWith('test_invoice_')) {
      const user = await User.findOne({ telegramId });
      if (!user) {
        return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
      }
      const amount = 10; // –¢–µ—Å—Ç–æ–≤–∞—è —Å—É–º–º–∞
      user.balance += amount;
      await user.save();
      return res.json({ message: "–¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!", balance: user.balance });
    }

    // ...—Ä–µ–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–≤–æ–π—Å–∞ —á–µ—Ä–µ–∑ CryptoBot...
    const response = await axios.get(
      `https://pay.crypt.bot/api/getInvoice?invoice_id=${invoiceId}`,
      {
        headers: {
          "Crypto-Pay-API-Token": process.env.CRYPTOBOT_TOKEN
        }
      }
    );
    if (!response.data.ok || !response.data.result) {
      return res.status(400).json({ error: "–ò–Ω–≤–æ–π—Å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ CryptoBot" });
    }
    const invoice = response.data.result;
    if (invoice.status !== 'paid') {
      return res.status(400).json({ error: "–ò–Ω–≤–æ–π—Å –Ω–µ –æ–ø–ª–∞—á–µ–Ω" });
    }
    const user = await User.findOne({ telegramId });
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }
    const amount = Number(invoice.amount);
    user.balance += amount;
    await user.save();
    res.json({ message: "–ë–∞–ª–∞–Ω—Å —É—Å–ø–µ—à–Ω–æ –ø–æ–ø–æ–ª–Ω–µ–Ω", balance: user.balance });
  } catch (err) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞ —á–µ—Ä–µ–∑ CryptoBot:", err?.response?.data || err);
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞" });
  }
});



const { ethers } = require('ethers');


// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–ª–æ–∫—á–µ–π–Ω–∞
const provider = new ethers.providers.JsonRpcProvider(process.env.BLOCKCHAIN_PROVIDER_URL);
const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

// –†–æ—É—Ç –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞
app.post('/addbalance', async (req, res) => {
    try {
        const { address, transactionHash } = req.body;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            return res.status(400).send('Transaction not found');
        }
        
        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const receipt = await tx.wait();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ –∏ –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è - –Ω–∞—à
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            return res.status(400).send('Invalid transaction');
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º—É –ø–µ—Ä–µ–≤–æ–¥–∞ (–≤ wei)
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await User.updateOne(
            { address: address.toLowerCase() },
            { $inc: { balance: parseFloat(amountInEth) } }
        );
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        res.status(500).send('Server error');
    }
});
const Transaction = require('./models/Transaction');

// –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ä–æ—É—Ç /addbalance
app.post('/addbalance', async (req, res) => {
    try {
        const { address, transactionHash } = req.body;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
        const existingTx = await Transaction.findOne({ txHash: transactionHash });
        if (existingTx) {
            return res.status(400).send('Transaction already processed');
        }
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const txRecord = new Transaction({
            userAddress: address.toLowerCase(),
            txHash: transactionHash,
            status: 'pending'
        });
        await txRecord.save();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –±–ª–æ–∫—á–µ–π–Ω–µ
        const tx = await provider.getTransaction(transactionHash);
        if (!tx) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Transaction not found');
        }
        
        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        const receipt = await tx.wait();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
        if (receipt.status !== 1 || tx.to.toLowerCase() !== wallet.address.toLowerCase()) {
            await txRecord.updateOne({ status: 'failed' });
            return res.status(400).send('Invalid transaction');
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º—É
        const value = tx.value;
        const amountInEth = ethers.utils.formatEther(value);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏ –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        await Promise.all([
            User.updateOne(
                { address: address.toLowerCase() },
                { $inc: { balance: parseFloat(amountInEth) } }
            ),
            txRecord.updateOne({
                status: 'completed',
                amount: parseFloat(amountInEth),
                blockNumber: receipt.blockNumber
            })
        ]);
        
        res.send({ success: true, newBalance: amountInEth });
    } catch (error) {
        console.error(error);
        if (txRecord) {
            await txRecord.updateOne({ status: 'failed' });
        }
        res.status(500).send('Server error');
    }
});
app.get('/testdb', async (req, res) => {
    try {
        const users = await User.find();
        const txs = await Transaction.find();
        res.send({ users, txs });
    } catch (error) {
        res.status(500).send(error.message);
    }
});

// –ù–æ–≤—ã–π —Ä–æ—É—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
app.get('/transactions/:address', async (req, res) => {
    try {
        const transactions = await Transaction.find({ 
            userAddress: req.params.address.toLowerCase() 
        }).sort({ timestamp: -1 });
        
        res.send(transactions);
    } catch (error) {
        res.status(500).send('Server error');
    }
});
// ‚úÖ –°–æ–∑–¥–∞—ë–º HTTP-—Å–µ—Ä–≤–µ—Ä –≤—Ä—É—á–Ω—É—é (–¥–ª—è WebSocket)
const server = http.createServer(app); // ‚úÖ –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º express –≤ http-—Å–µ—Ä–≤–µ—Ä
const wss = new WebSocket.Server({ server });

let clients = new Set();

wss.on('connection', (ws) => {
  clients.add(ws);
  console.log('–ü–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫–ª–∏–µ–Ω—Ç. –°–µ–π—á–∞—Å –æ–Ω–ª–∞–π–Ω:', clients.size);
  broadcastOnline();

  ws.on('close', () => {
    clients.delete(ws);
    console.log('–ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–∏–ª—Å—è. –°–µ–π—á–∞—Å –æ–Ω–ª–∞–π–Ω:', clients.size);
    broadcastOnline();
  });
});

function broadcastOnline() {
  const count = clients.size;
  const message = JSON.stringify({ online: count });

  clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}
app.get('/users/:param')  // –û—à–∏–±–∫–∞: –ø–æ—Å–ª–µ `:` –Ω–µ—Ç –∏–º–µ–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞

// üöÄ –∑–∞–ø—É—Å–∫
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
});